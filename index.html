<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Smart Video Recorder</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 0;
    background: #111;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
  }

  header {
    text-align: center;
    padding: 10px;
    font-size: 1.2em;
    background: #222;
    width: 100%;
  }

  #preview, #recorded {
    width: 100%;
    height: auto;
    max-height: 60vh;
    background: #000;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-top: 10px;
  }

  button {
    flex: 1 1 40%;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    background: #333;
    color: #fff;
  }

  button:disabled {
    opacity: 0.4;
  }

  #status {
    text-align: center;
    margin: 8px 0;
    font-size: 0.95em;
  }

  @media (min-width: 600px) {
    button { flex: none; width: auto; padding: 10px 20px; }
  }
</style>
</head>
<body>
  <header>ðŸŽ¥ Smart Video Recorder</header>

  <video id="preview" autoplay muted playsinline></video>
  <video id="recorded" controls style="display:none;"></video>

  <div id="status">Initializing...</div>

  <div class="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="switchBtn">Switch Camera</button>
    <button id="downloadBtn" disabled>Download</button>
    <button id="deleteBtn" disabled>Delete</button>
  </div>

<script>
let mediaStream = null;
let mediaRecorder = null;
let recordedChunks = [];
let usingFront = true;
let recordedBlob = null;
let recordedUrl = null;

// IndexedDB helpers for saving blobs locally
const dbName = "videoRecorderDB";
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, 1);
    req.onupgradeneeded = e => e.target.result.createObjectStore("videos");
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e);
  });
}

async function saveToDB(blob) {
  const db = await openDB();
  const tx = db.transaction("videos", "readwrite");
  tx.objectStore("videos").put(blob, "lastRecording");
  tx.oncomplete = () => console.log("Saved to IndexedDB");
}

async function loadFromDB() {
  const db = await openDB();
  return new Promise((resolve) => {
    const tx = db.transaction("videos", "readonly");
    const req = tx.objectStore("videos").get("lastRecording");
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => resolve(null);
  });
}

async function initCamera() {
  if (!location.protocol.startsWith("https") && location.hostname !== "localhost") {
    document.getElementById("status").textContent =
      "âš ï¸ Camera requires HTTPS or localhost.";
    throw new Error("Insecure origin");
  }
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  const constraints = { video: { facingMode: usingFront ? "user" : "environment" }, audio: true };
  mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
  const preview = document.getElementById("preview");
  preview.srcObject = mediaStream;
  document.getElementById("status").textContent =
    "Camera ready (" + (usingFront ? "front" : "rear") + ")";
}

async function startRecording() {
  recordedChunks = [];
  mediaRecorder = new MediaRecorder(mediaStream);
  mediaRecorder.ondataavailable = e => e.data.size > 0 && recordedChunks.push(e.data);
  mediaRecorder.onstop = async () => {
    recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
    recordedUrl = URL.createObjectURL(recordedBlob);
    const recorded = document.getElementById("recorded");
    recorded.src = recordedUrl;
    recorded.style.display = "block";
    await saveToDB(recordedBlob);
    updateUI("Recording stopped â€” saved locally âœ…");
  };
  mediaRecorder.start();
  updateUI("Recording... ðŸ”´");
}

function stopRecording() {
  mediaRecorder?.stop();
}

function updateUI(msg) {
  document.getElementById("status").textContent = msg;
  document.getElementById("startBtn").disabled = mediaRecorder && mediaRecorder.state === "recording";
  document.getElementById("stopBtn").disabled = !(mediaRecorder && mediaRecorder.state === "recording");
  document.getElementById("downloadBtn").disabled = !recordedBlob;
  document.getElementById("deleteBtn").disabled = !recordedBlob;
}

document.getElementById("startBtn").onclick = async () => {
  await initCamera();
  startRecording();
  document.getElementById("startBtn").disabled = true;
  document.getElementById("stopBtn").disabled = false;
};

document.getElementById("stopBtn").onclick = () => {
  stopRecording();
  document.getElementById("startBtn").disabled = false;
  document.getElementById("stopBtn").disabled = true;
};

document.getElementById("switchBtn").onclick = async () => {
  usingFront = !usingFront;
  await initCamera();
};

document.getElementById("downloadBtn").onclick = () => {
  if (!recordedBlob) return;
  const a = document.createElement("a");
  a.href = recordedUrl;
  a.download = "recording_" + Date.now() + ".webm";
  a.click();
};

document.getElementById("deleteBtn").onclick = async () => {
  const db = await openDB();
  const tx = db.transaction("videos", "readwrite");
  tx.objectStore("videos").delete("lastRecording");
  recordedBlob = null;
  recordedChunks = [];
  if (recordedUrl) URL.revokeObjectURL(recordedUrl);
  document.getElementById("recorded").style.display = "none";
  updateUI("Recording deleted from memory ðŸ—‘ï¸");
};

// Load any saved recording on page load
window.addEventListener("load", async () => {
  const saved = await loadFromDB();
  if (saved) {
    recordedBlob = saved;
    recordedUrl = URL.createObjectURL(saved);
    const rec = document.getElementById("recorded");
    rec.src = recordedUrl;
    rec.style.display = "block";
    updateUI("Restored saved recording âœ…");
  } else {
    updateUI("Ready to record.");
  }
  initCamera().catch(console.warn);
});

window.addEventListener("beforeunload", () => {
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
});
</script>
</body>
</html>
